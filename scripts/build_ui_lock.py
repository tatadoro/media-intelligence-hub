from __future__ import annotations

import argparse
import hashlib
from pathlib import Path
from typing import Iterable, Optional, Tuple

try:
    from packaging.utils import parse_wheel_filename
except Exception as exc:  # pragma: no cover
    raise SystemExit(
        "[ERROR] packaging is required (comes with pip). "
        "Try: python3 -m pip install packaging"
    ) from exc


def sha256_file(path: Path) -> str:
    h = hashlib.sha256()
    with path.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def iter_artifacts(wheels_dir: Path) -> Iterable[Path]:
    items = list(wheels_dir.glob("*.whl"))
    items += list(wheels_dir.glob("*.tar.gz"))
    items += list(wheels_dir.glob("*.zip"))
    return sorted(items)


def _parse_sdist_filename(filename: str) -> Optional[Tuple[str, str]]:
    base = filename
    if base.endswith(".tar.gz"):
        base = base[:-7]
    elif base.endswith(".zip"):
        base = base[:-4]
    else:
        return None
    if "-" not in base:
        return None
    name, version = base.rsplit("-", 1)
    if not name or not version:
        return None
    return name, version


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--wheels-dir", required=True)
    ap.add_argument("--out", required=True)
    args = ap.parse_args()

    wheels_dir = Path(args.wheels_dir).resolve()
    out_path = Path(args.out).resolve()

    artifacts = list(iter_artifacts(wheels_dir))
    if not artifacts:
        raise SystemExit(f"[ERROR] No artifacts found in {wheels_dir}")

    entries = []
    for art in artifacts:
        if art.name.endswith(".whl"):
            name, version, _build, _tags = parse_wheel_filename(art.name)
        else:
            parsed = _parse_sdist_filename(art.name)
            if not parsed:
                continue
            name, version = parsed
        digest = sha256_file(art)
        entries.append((name, version, digest))

    # Sort by normalized name, then version
    entries.sort(key=lambda x: (x[0].lower(), x[1]))

    lines = [
        "# Auto-generated. Do not edit.",
        "# Generated by scripts/build_ui_lock.py",
    ]
    for name, version, digest in entries:
        lines.append(f"{name}=={version} --hash=sha256:{digest}")

    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


if __name__ == "__main__":
    main()
